// Generated by CoffeeScript 1.9.3
(function() {
  "use strict";
  var Ivoire, Owlbear, _, parser, roll_fudge,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Ivoire = require('ivoire');

  _ = require('lodash');

  Owlbear = require('owlbear');

  parser = new Owlbear();

  Ivoire.prototype.roll = function(dexpr) {
    var all_results, count, die, explode, expr, final, i, j, keep, len, opts, r, ref, reroll, result, results, roll, rolls, sides;
    if (_.isNumber(dexpr)) {
      this.panic_if(!_.isFinite(dexpr, "Numeric dice expression must be finite"));
      this.panic_if(dexpr < 1, "Numeric dice expression must be greater than 0");
      dexpr = Math.floor(dexpr);
      dexpr = "1d" + dexpr;
    }
    if (_.isString(dexpr)) {
      rolls = parser.parse(dexpr);
    } else {
      rolls = Array.prototype.slice.apply(arguments);
    }
    all_results = [];
    for (i = 0, len = rolls.length; i < len; i++) {
      roll = rolls[i];
      if ('operator' in roll) {
        all_results.push(roll.operator);
      } else if ('constant' in roll) {
        all_results.push(roll.constant);
      } else {
        count = roll.count || 1;
        keep = roll.keep;
        die = roll.die || {};
        sides = die.sides || 6;
        reroll = die.reroll || [];
        explode = die.explode || [];
        results = [];
        opts = {
          min: 1,
          max: sides
        };
        for (r = j = 0, ref = count - 1; 0 <= ref ? j <= ref : j >= ref; r = 0 <= ref ? ++j : --j) {
          result = this.integer(opts);
          while (indexOf.call(reroll, result) >= 0) {
            result = this.integer(opts);
          }
          results.push(result);
          while (indexOf.call(explode, result) >= 0) {
            result = this.integer(opts);
            results.push(result);
          }
        }
        if (_.isFinite(keep) && keep < results.length) {
          results.sort();
          results.reverse();
          results = results.slice(0, keep);
        }
        all_results.push(_.sum(results));
      }
    }
    expr = all_results.join(' ');
    final = eval(expr);
    return final;
  };

  roll_fudge = Ivoire.prototype.roll_fudge = function(num) {
    var i, n, ref;
    this.panic_if(num < 1, "Can't throw fewer than 1 fudge die!");
    num = num || 4;
    for (n = i = 0, ref = num; 0 <= ref ? i <= ref : i >= ref; n = 0 <= ref ? ++i : --i) {
      return _.sum(this.pick(roll_fudge.sides));
    }
  };

  roll_fudge.sides = [-1, -1, 0, 0, 1, 1];

  module.exports = Ivoire;

}).call(this);
